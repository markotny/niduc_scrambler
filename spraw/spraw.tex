\documentclass[polish, 11pt]{article}
    
\usepackage[a4paper, margin=25mm]{geometry}
\usepackage{babel,polski}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{booktabs,multirow,multicol}

\usepackage{graphicx}
\graphicspath{{DVB/} {V34/} {img/}}

\usepackage{xcolor}
\usepackage[font=small,labelfont=bf]{caption}
\captionsetup[figure]{name=Rys.}

\newcommand{\results}[3][1.0]{
    \includegraphics[width=#1\textwidth]{#2}
    \captionof{figure}{#3\label{fig:#2}}
}

\begin{document}
\begin{titlepage}
    \centering
    {\scshape\LARGE Niezawodność i diagnostyka układów cyfrowych 2\\ projekt \par}
    \vspace{1cm}
    {\scshape\Large,,Unikanie utraty synchronizacji przy pomocy randomizacji (Scrambling)''\par}
    \vspace{2cm}
    {\itshape\Large Janusz Długosz --- 235746\/\par}
    {\itshape\Large Jakub Dorda --- 235013\/\par}
    {\itshape\Large Marcin Kotas --- 235098\/\par}
    \vfill
    Prowadzący:\par
    Doc.~dr inż.~Jacek \textsc{Jarnicki}

    \vfill

    {\large Wrocław, \today\par}

\end{titlepage}

\tableofcontents
\newpage

\section{Wstęp}

\section{Scramblery - teoria}
    \subsection{Przeznaczenie}
	    Scramblery są kluczowym elementem warstwy fizycznej systemu transmisji bezprzewodowej, poza zapewnieniem
	    kodowania interwałowego oraz modulacji transmisji, powodami dla których używa się układów scaramblujących są:
	    \begin{itemize}
	    	\item Dokładne odtworzenie czasu w układzie odbiorczym potrzebnego do synchronizacji transmisji,
	    	bez konieczności używania redundantnych znaków końca ramki. Rozwiązuje to problem potrzeby stosowania
	    	układu odtwarzającego taktowanie. Automatyzuje kontrolę wzmocnienia sygnału oraz pracę innych układów
	    	przetwarzających sygnał, dzięki eliminacji długich ciągów zer i jedynek.
	    	\item Zmniejszenie zakłóceń sygnału między falami nośnymi, bardziej zróżnicowane dane zapewniają
	    	rozproszenie widma sygnału co przekłada się na mniejszą wrażliwość na zakłócenia między sąsiednimi
	    	kanałami transmisji.
	    	\item Prosta metoda szyfrowania transmisji, stosowana dla sygnałów analogowych. Zarówno scrambler
	    	w urządzeniu nadawczym jak i descrambler w urządzeniu odbiorczym muszą posiadać ten sam klucz/ciąg
	    	znaków w celu poprawnego dekodowania danych.
	    \end{itemize}
	    
    \subsection{Typy scramblerów}
	    \subparagraph{Addytywny (synchroniczny)\\}
		    Scramblery synchroniczne przetwarzają dane wejściowe przez zastosowanie podwójnej operacji xor z dwoma najmłodszymi
		    bitami pseudo losowego ciągu znaków oraz bitem wejścia. Po każdej operacji ciąg - klucz jest przesuwany o jedną
		    pozycję w prawo, a wynik xor dwóch najmłodszych bitów zapisywany na pozycji pierwszej. Ta implementacja scramblera
		    posiada wadę konieczności synchronizacji między scramblerem, a descramblerem przez zastosowanie zakodowanego słowa
		    inicjalizującego przeładowanie ciągu znaków losowych do stanu początkowego, dzieje się to na początku każdej nowej ramki
		    danych. Scrambler addytywny jest zarówno descramblerem bez konieczności dodatkowych modyfikacji. 
		    
		    \vspace{0.5cm}
		    \begin{center}
		    	\results[0.7]{sc_add}{Scrambler addytywny\\źródło: wikipedia.org}
		    \end{center}
		    
	    \subparagraph{Multiplikacyjny (samo-synchronizujący)\\}
		    Scramblery multyplikacyjne, nazywane są tak ponieważ wykonują mnożenie sygnału wejściowego z funkcją przejścia ciągu
		    znaków scramblera. W implementacji zgodnej ze standardem V.34 dokonuje operacji xor na 18 i 23 bicie klucza, jest
		    to tzw. funkca przejścia scramblera. Wynikiem jest pierwszy bit ciągu klucza, po operacji xor z bitem wejściowym oraz
		    wynikiem funkcji przejścia. Skrambler multiplikacyjny jest rekurencyjny, a descrambler nie, przez co ich konstrukcje
		    różnią się. Skramblery multiplikacyjne, w przeciwieństwie do addytywnych, nie wymagają synchronizacji ciągu znaków
		    z deskramblerami.
		    
		    \vspace{0.5cm}
		    \begin{center}
		    	\results[0.7]{sc_mul1}{Scrambler multiplikacyjny V.34\\źródło: wikipedia.org}
		    	\vspace{0.5cm}
		    	\results[0.7]{sc_mul2}{Descrambler multiplikacyjny V.34\\źródło: wikipedia.org}
		    \end{center}

\section{Opis symulatora}
    \subsection{Założenia}

    \subsection{Opis programów}

\section{Eksperymenty symulacyjne}
    \subsection{Plan eksperymentów}
        Eksperymenty przeprowadzone są dla każdego zestawu danych --- ciągi zer, jedynek oraz losowych bitów.
        Rozmiar danych dla którego przedstawiono wykresy wynosił 1000000 elementów.

        W pierwszej kolejności ciągi danych są przekazywane do obu scramblerów.
        Funkcja monitor generuje wykres przedstawiający liczbę wystąpień oraz długości ciągów zer i jedynek w danych.

        W celu wyznaczenia wskaźnika Bit Error Rate dane zescramblowane przepuszczane są przez kanał.
        Kanał z zadanym prawdopodobieństwem zamienia kolejne bity danych na przeciwne.
        W ramach eksperymentu prawdopodobieństwo przekłamania zmieniane jest od 0\% do 10\% co 0,5\%.

        Po wyjściu z kanału dane są descramblowane, a następnie porównywane z oryginalnym zestawem danych.
        Liczba błędnych bitów dzielona jest przez rozmiar danych, aby uzyskać wskaźnik BER.\
        
    \subsection{Wyniki eksperymentów}
        Wykresy~\ref{fig:DVB_00},~\ref{fig:DVB_01} oraz~\ref{fig:V34_00},~\ref{fig:V34_01} przedstawiają ciąg zer po scramblingu odpowiednio DVB oraz V34.
        W przypadku scramblera V34 żadne bity nie zostały zamienione, ponieważ na początku w buforze scramblera znajdują się same zera.
        Operacja \(0 \oplus 0\) zawsze da w wyniku 0, więc stan bufora nigdy się nie zmieni.
        Scrambler DVB zawsze zaczyna od słowa SYNC w buforze, co eliminuje ten problem.

        W przypadku ciągu jedynek (wykresy~\ref{fig:DVB_10},~\ref{fig:DVB_11} oraz~\ref{fig:V34_10},~\ref{fig:V34_11}) oba scramblery zachowują się już poprawnie.
        Liczba wystąpień poszczególnych długości ciągów jest podobna dla obu rodzajów scramblera. 
        Scrambler V34 wygenerował jednak najdłuższy ciąg długości 18, natomiast DVB długości 14.

        Dla danych generowanych losowo (wykresy~\ref{fig:DVB_R0},~\ref{fig:DVB_R1} oraz~\ref{fig:V34_R0},~\ref{fig:V34_R1})
        oba scramblery dały podobne wyniki.

        Bit Error Rate scramblera V34 (wykres~\ref{fig:BER_V34}) w zmierzonym zakresie jest znacznie gorszy od scramblera DVB (wykres~\ref{fig:BER_DVB}).
        Rośnie on około 2 razy szybciej.

    \subsection{Wnioski}
        Scramblery działają poprawnie, dane wyjściowe składają się głównie z krótkich ciągów tych samych bitów.
        Bieżąca implementacja kanału nie jest wystarczająco dopracowana na potrzeby symulacji.
        Przekłamania bitów powinny odbywać się z prawdopodobieństwem, które rośnie wraz z długością ciągu tych samych bitów w danych.
        Dopiero wtedy widoczne stałyby się zyski wynikające z użycia scramblerów.
        
        Obecnie z eksperymentu wynika, iż użycie scramblera skutkuje w najlepszym wypadku niepogorszeniem współczynnika BER (dla DVB BER = prawdopodobieństwu przekłamania),
        a w najgorszym przypadku dwukrotnym wzroście współczynnika BER (dla V34).
        Wzrost BER dla V34 wynika z faktu, że bity danych ładowane są do bufora, a więc przekłamany bit może skutkować późniejszym dodatkowym przekłamaniem.

        Eksperyment można więc uznać za nieudany, ponieważ użyty symulator nie uwzględnia istotnych zjawisk zachodzących podczas transmisji.

\newpage
\section{Wykresy}
    \subsection{DVB}

    \begin{minipage}[t]{.5\textwidth}
        \results{DVB_00}{Dane wejściowe: ciąg zer}
    \end{minipage}%
    \hspace{1cm}
    \begin{minipage}[t]{.5\textwidth}
        \results{DVB_01}{Dane wejściowe: ciąg zer}
    \end{minipage}%
    \vspace{1.5cm}
    \begin{minipage}[t]{.5\textwidth}
        \results{DVB_10}{Dane wejściowe: ciąg jedynek}
    \end{minipage}%
    \hspace{1cm}
    \begin{minipage}[t]{.5\textwidth}
        \results{DVB_11}{Dane wejściowe: ciąg jedynek}
    \end{minipage}%
    \vspace{1.5cm}
    \begin{minipage}[t]{.5\textwidth}
        \results{DVB_R0}{Dane wejściowe: ciąg losowych bitów}
    \end{minipage}%
    \hspace{1cm}
    \begin{minipage}[t]{.5\textwidth}
        \results{DVB_R1}{Dane wejściowe: ciąg losowych bitów}
    \end{minipage}

\subsection{V34}
    \begin{minipage}[t]{.5\textwidth}
        \results{V34_00}{Dane wejściowe: ciąg zer}
    \end{minipage}%
    \hspace{1cm}
    \begin{minipage}[t]{.5\textwidth}
        \results{V34_01}{Dane wejściowe: ciąg zer}
    \end{minipage}%
    \vspace{1.5cm}
    \begin{minipage}[t]{.5\textwidth}
        \results{V34_10}{Dane wejściowe: ciąg jedynek}
    \end{minipage}%
    \hspace{1cm}
    \begin{minipage}[t]{.5\textwidth}
        \results{V34_11}{Dane wejściowe: ciąg jedynek}
    \end{minipage}%
    \vspace{1.5cm}
    \begin{minipage}[t]{.5\textwidth}
        \results{V34_R0}{Dane wejściowe: ciąg losowych bitów}
    \end{minipage}%
    \hspace{1cm}
    \begin{minipage}[t]{.5\textwidth}
        \results{V34_R1}{Dane wejściowe: ciąg losowych bitów}
    \end{minipage}

\subsection{Bit Error Rate}
        \results{BER_DVB}{BER dla DVB}
        \vspace{1.5cm}
        \results{BER_V34}{BER dla V34}

\end{document}